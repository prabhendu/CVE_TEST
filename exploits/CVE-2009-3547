CVE-2009-3547: Linux kernel Pipe NULL Pointer Dereference Race Condition

with 22 comments

This awesome vulnerability was discovered by Earl Chew and quickly noticed and classified as a vulnerability by Eugene Teo of Red Hat.
This vulnerability is extremely straightforward to exploit after all the exploit releases of spender on NULL pointer dereference bugs. So, here is some code from fs/pipe.c as seen in 2.6.29 release of the Linux kernel…
view source
print?
01	const struct file_operations write_pipefifo_fops = {
02	   ...
03	        .open           = pipe_write_open,
04	   ...
05	};
06	   ...
07	static int
08	pipe_write_open(struct inode *inode, struct file *filp)
09	{
10	        mutex_lock(&inode->i_mutex);
11	        inode->i_pipe->writers++;
12	        mutex_unlock(&inode->i_mutex);
13	 
14	        return 0;
15	}

The code isn’t that hard to understand. When you open a pipe for writing, this routine is called and it will increment the ‘inode->i_pipe->writers’ that represents the current number of writers to that pipe as you might have guessed. Of course, it is doing this in a MUTEX lock to avoid race conditions with other code that might change that counter’s value.
The equivalent functions that release a pipe are the following three:
view source
print?
01	static int
02	pipe_read_release(struct inode *inode, struct file *filp)
03	{
04	        return pipe_release(inode, 1, 0);
05	}
06	 
07	static int
08	pipe_write_release(struct inode *inode, struct file *filp)
09	{
10	        return pipe_release(inode, 0, 1);
11	}
12	 
13	static int
14	pipe_rdwr_release(struct inode *inode, struct file *filp)
15	{
16	        int decr, decw;
17	 
18	        decr = (filp->f_mode & FMODE_READ) != 0;
19	        decw = (filp->f_mode & FMODE_WRITE) != 0;
20	        return pipe_release(inode, decr, decw);
21	}

If a process attempts to open a pipe while another one releases it, and assuming that the release happens first, the ‘open’ routines will lead to a NULL pointer dereference since ‘inode->i_pipe’ would be NULL.
This amazing vulnerability was fixed by applying the following patch:
view source
print?
01	pipe_read_open(struct inode *inode, struct file *filp)
02	 {
03	-       /* We could have perhaps used atomic_t, but this and friends
04	-          below are the only places.  So it doesn't seem worthwhile.  */
05	+       int ret = -ENOENT;
06	+
07	        mutex_lock(&inode->i_mutex);
08	-       inode->i_pipe->readers++;
09	+
10	+       if (inode->i_pipe) {
11	+               ret = 0;
12	+               inode->i_pipe->readers++;
13	+       }
14	+
15	        mutex_unlock(&inode->i_mutex);
16	 
17	-       return 0;
18	+       return ret;
19	 }
20	 
21	 static int
22	 pipe_write_open(struct inode *inode, struct file *filp)
23	 {
24	+       int ret = -ENOENT;
25	+
26	        mutex_lock(&inode->i_mutex);
27	-       inode->i_pipe->writers++;
28	+
29	+       if (inode->i_pipe) {
30	+               ret = 0;
31	+               inode->i_pipe->writers++;
32	+       }
33	+
34	        mutex_unlock(&inode->i_mutex);
35	 
36	-       return 0;
37	+       return ret;
38	 }
39	 
40	 static int
41	 pipe_rdwr_open(struct inode *inode, struct file *filp)
42	 {
43	+       int ret = -ENOENT;
44	+
45	        mutex_lock(&inode->i_mutex);
46	-       if (filp->f_mode & FMODE_READ)
47	-               inode->i_pipe->readers++;
48	-       if (filp->f_mode & FMODE_WRITE)
49	-               inode->i_pipe->writers++;
50	+
51	+       if (inode->i_pipe) {
52	+               ret = 0;
53	+               if (filp->f_mode & FMODE_READ)
54	+                       inode->i_pipe->readers++;
55	+               if (filp->f_mode & FMODE_WRITE)
56	+                       inode->i_pipe->writers++;
57	+       }
58	+
59	        mutex_unlock(&inode->i_mutex);
60	 
61	-       return 0;
62	+       return ret;
63	 }

As you can see, it is a simple series of NULL checks against ‘inode->i_pipe’ on pipe_read_open(), pipe_write_open() and pipe_rdwr_open().
This results in a completely user control increment of an arbitrary value located at ‘NULL->readers’ of ‘NULL->writers’. Does this reminds you anything? :P
There might also be easier ways to exploit this. Anyway, too bad that such a nice bug was killed. :( 
