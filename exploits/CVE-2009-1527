CVE-2009-1527:This issue was reported on 26 April 2009 by Oleg Nesterov of Red Hat and affects Linux kernel up to 2.6.29 release. The vulnerability is located in ptrace_attach() routine of kernel/ptrace.c. Here is some code as seen in 2.6.29 release:

175 int ptrace_attach(struct task_struct *task)
176 {
177        int retval;
178        unsigned long flags;
179
180        audit_ptrace(task);
181
182        retval = -EPERM;
183        if (same_thread_group(task, current))
184                goto out;
185
186        /* Protect exec's credential calculations against our interference;
187         * SUID, SGID and LSM creds get determined differently under ptrace.
188         */
189        retval = mutex_lock_interruptible(&current->cred_exec_mutex);
190        if (retval  < 0)
191                goto out;
192
193        retval = -EPERM;
194 repeat:
       ...
230 bad:
231        write_unlock_irqrestore(&tasklist_lock, flags);
232        task_unlock(task);
233        mutex_unlock(&current->cred_exec_mutex);
234 out:
235        return retval;
236 }

Eugene Teo quickly noticed the potential vulnerability in this code. As you can see at lines 189 and 233, ptrace_attach() uses the current process’ MUTEX to lock and serialize the two tasks (the current one, and the one passed to that function as an argument). However, the above code incorrectly uses the current task’s cred_exec_mutex instead of the task’s to be traced. This creates a race condition which allows a user to ptrace(PTRACE_ATTACH) during the execution of an execve() call to a SUID binary. But this new member (cred_exec_mutex) was added to the task_struct to avoid exactly this behavior as you can read at include/linux/sched.h:

1114 struct task_struct {
       ...
1245        struct mutex cred_exec_mutex;   /* execve vs ptrace cred calculation mutex */
       ...
1420 };

This can lead to local privilege escalation and the patch was to change the MUTEX locks accordingly like this:

         */
-       retval = mutex_lock_interruptible(&current->cred_exec_mutex);
+       retval = mutex_lock_interruptible(&task->cred_exec_mutex);
        if (retval  < 0)

And:

        task_unlock(task);
-       mutex_unlock(&current->cred_exec_mutex);
+       mutex_unlock(&task->cred_exec_mutex);
 out:
