ref.http://www.reddit.com/r/netsec/comments/1eb9iw/sdfucksheeporgs_semtexc_local_linux_root_exploit/c9ykrck

Vuln involves the event_id variable in kernel/events/core.c:perf_swevent_init(),
which is a signed integer with only its upper bound checked. On close of the
event, it will do:

    static void sw_perf_event_destroy(struct perf_event *event)
    {
        u64 event_id = event->attr.config;

        WARN_ON(event->parent);

        static_key_slow_dec(&perf_swevent_enabled[event_id]);
        swevent_hlist_put(event);
    }

The event_id is thus casted to a u64, creating an effective index > 2G. So
there's a somewhat arbitrary memory decrement here.

The exploit provides a negative event_id, which when casted and converted into
an array index, combined with the location of the kernel in a 64bit address
space, results in an address in userland within a reasonable range. The exploit
prepares for this by mapping that range and filling it with known contents. The
decrement performed by the kernel will then modify some data in the mapping,
which the exploit will be able to find. I believe an increment is also performed
via the code below, but the indexes of -1 and -2 were likely chosen so as to not
have this cause modification of anything important on the kernels tested.

By knowing the address of the modified data, the event_id provided to the
kernel, and the size of the elements of the array being indexed, the exploit can
compute the address of the base of the array. Then it acquires the IDT base and
targets the overflow interrupt vector. I think here it may be targeting it with
different code:

static_key_slow_inc(&perf_swevent_enabled[event_id]);

from perf_swevent_init(), which will allow it to actually use its negative
index. It then targets the interrupt vector entry with the increment from the
vulnerable code. It modifies the handler to cause the exploit's shellcode in
userland to run upon its execution of 'int 0x4'. The shellcode finds and
modifies the credentials for the current task, replacing uids/gids with 0 and
granting full capabilities.

This is not an exact interpretation of the source, which has bugs, but how it
should work in general.

The address inference via userland would be prevented by UDEREF, the IDT
modification would be prevented by KERNEXEC, and SMEP would prevent the
execution of shellcode in userland.

-Brad
